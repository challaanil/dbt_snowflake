import boto3
import json
import smbclient
import datetime
from zoneinfo import ZoneInfo
import socket
import os
import logging
import time

# Setting logger
msg_format = '%(asctime)s %(levelname)s %(name)s: %(message)s'
datetime_format = '%Y-%m-%d %H:%M:%S'
logging.basicConfig(format=msg_format, datefmt=datetime_format)
logger = logging.getLogger()
logger.setLevel(logging.INFO)

job_name = "lambda_job"

def get_credentials(secret_name):
    secretsmanager_client = boto3.client('secretsmanager', region_name='us-west-2')
    try:
        logger.info(f"Fetching secret for :{secret_name}")
        get_secret_value_response = secretsmanager_client.get_secret_value(SecretId=secret_name)
        if 'SecretString' in get_secret_value_response:
            secret = get_secret_value_response['SecretString']
            secret_dict = json.loads(secret)
            logger.info("Successfully fetched secret as string")
            return secret_dict
        else:
            decoded_binary_secret = base64.b64decode(get_secret_value_response['SecretBinary'])
            secret_dict = json.loads(decoded_binary_secret)
            logger.info("Successfully fetched secret as binary.")
            return secret_dict
    except Exception as e:
        logger.error(f"Error fetching secret: {e}", exc_info=True)
        return None

def configure_smb(smb_username, smb_password):
    try:
        if smb_username and smb_password:
            smbclient.ClientConfig(username=smb_username, password=smb_password)
            logger.info(f"SMB client configured successfully with username: {smb_username}")
        else:
            logger.error("SMB credentials are missing. Cannot configure SMB client.")
    except Exception as e:
        logger.error(f"Failed to configure SMB client: {e}", exc_info=True)

def is_port_open(host, port):
    try:
        logger.info(f"Checking if port {port} on host {host} is open.")
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(60)
        result = sock.connect_ex((host, port))
        if result == 0:
            logger.info(f"Port {port} on host {host} is open")
            return True
        else:
            logger.warning(f"Port {port} on host {host} is closed")
            return False
    except socket.error as e:
        logger.error(f"Socket error while checking port {port} on host {host}: {e}", exc_info=True)
        return False
    finally:
        sock.close()
        logger.info("Socket connection closed")

def file_with_timestamp(use_timestamp, file_path):
    try:
        if use_timestamp:
            cst = ZoneInfo("America/Chicago")
            timestamp = datetime.datetime.now(cst).strftime("%Y%m%d%H%M%S")
            filename, file_ext = os.path.splitext(os.path.basename(file_path))
            filename_with_timestamp = f"{filename}_{timestamp}{file_ext}"
            logger.info(f"Generated file name with timestamp: {filename_with_timestamp}")
        else:
            filename_with_timestamp = os.path.basename(file_path)
            logger.info(f"Generated file name without timestamp: {filename_with_timestamp}")
        return filename_with_timestamp
    except Exception as e:
        logger.error(f"Failed to generate file name. Error: {e}", exc_info=True)
        return None

def matches_filters(file_key, prefixes=None, extensions=None):
    try:
        if prefixes:
            prefix_match = any(file_key.startswith(prefix) for prefix in prefixes)
        else:
            prefix_match = True

        if extensions:
            extension_match = any(file_key.endswith(ext) for ext in extensions)
        else:
            extension_match = True

        return prefix_match and extension_match
    except Exception as e:
        logger.error(f"Error matching filters for file {file_key}: {e}", exc_info=True)
        return False

def transfer_file_to_smb(bucket_name, s3_key, smb_path, use_timestamp, chunk_size_mb, prefixes=None, extensions=None):
    try:
        if not matches_filters(s3_key, prefixes, extensions):
            logger.info(f"File {s3_key} does not match the filters. Skipping.")
       ll     return False

        s3_client = boto3.client('s3')
        logger.info(f"Starting file transfer: S3 {s3_key} to SMB {smb_path}")

        # Get file from S3
        response = s3_client.get_object(Bucket=bucket_name, Key=s3_key)
        file_stream = response['Body']
        file_size = response['ContentLength']

        # Generate timestamped file name if required
        filename = file_with_timestamp(use_timestamp, s3_key)
        smb_file_path = os.path.join(smb_path, filename)

        # Write to SMB
        chunk_size = chunk_size_mb * 1024 * 1024
        with smbclient.open_file(smb_file_path, mode='w') as smb_file:
            logger.info(f"Writing to SMB in chunks of {chunk_size_mb} MB.")
            while chunk := file_stream.read(chunk_size):
                smb_file.write(chunk)

        logger.info(f"File {s3_key} transferred to {smb_file_path} successfully.")
        return True
    except Exception as e:
        logger.error(f"Failed to transfer file {s3_key} to SMB. Error: {e}", exc_info=True)
        return False

def lambda_handler(event, context):
    try:
        logger.info("Lambda function execution started.")
        secret_name = os.getenv('secret_name')
        credentials = get_credentials(secret_name)

        if not credentials:
            return {"statusCode": 500, "body": "Failed to fetch credentials."}

        configure_smb(credentials['username'], credentials['password'])

        bucket_name = event['bucket_name']
        s3_prefixes = event.get('s3_prefixes', "").split(',')
        s3_extensions = event.get('s3_extensions', "").split(',')
        smb_path = event['smb_path']
        use_timestamp = event.get('use_timestamp', True)
        chunk_size_mb = event.get('chunk_size_mb', 5)

        s3_client = boto3.client('s3')
        paginator = s3_client.get_paginator('list_objects_v2')

        for page in paginator.paginate(Bucket=bucket_name):
            for obj in page.get('Contents', []):
                file_key = obj['Key']
                transfer_file_to_smb(bucket_name, file_key, smb_path, use_timestamp, chunk_size_mb, prefixes=s3_prefixes, extensions=s3_extensions)

        return {"statusCode": 200, "body": "Files transferred successfully."}
    except Exception as e:
        logger.error(f"Error in lambda handler: {e}", exc_info=True)
        return {"statusCode": 500, "body": "Internal server error."}
    finally:
        logger.info("Lambda execution completed.")
